# 卢卡斯定理

A、B是非负整数，p是质数。AB写成p进制：A=a[n]a[n-1]...a[0]，B=b[n]b[n-1]...b[0]。则组合数C(A,B)与C(a[n],b[n])*C(a[n-1],b[n-1])*...*C(a[0],b[0]) modp同余。即：

**Lucas(n,m,p)=c(n%p,m%p)\*Lucas(n/p,m/p,p)**

简言之，Lucas定理是用来求 c(n,m) mod p，p为素数的值。

[洛谷-P3807【模板】卢卡斯定理](https://www.luogu.org/problemnew/show/P3807)

给定n,m,p$$(1\le n,m,p\le 10^5)$$

求 $$C_{n+m}^{m}\ mod\ p$$ 

保证P为prime

C表示组合数。

一个测试点内包含多组数据。

```cpp
#include <bits/stdc++.h>
#define N 100010
using namespace std;
typedef long long ll;
ll a[N];
int p;
ll pow(ll y, int z, int p)
{
    y %= p;
    ll ans = 1;
    for (int i = z; i; i >>= 1, y = y * y % p)
        if (i & 1)
            ans = ans * y % p;
    return ans;
}
ll C(ll n, ll m)
{
    if (m > n)
        return 0;
    return ((a[n] * pow(a[m], p - 2, p)) % p * pow(a[n - m], p - 2, p) % p);
}
ll Lucas(ll n, ll m)
{
    if (!m)
        return 1;
    return C(n % p, m % p) * Lucas(n / p, m / p) % p;
}
inline int read()
{
    int f = 1, x = 0;
    char ch;
    do
    {
        ch = getchar();
        if (ch == '-')
            f = -1;
    } while (ch < '0' || ch > '9');
    do
    {
        x = x * 10 + ch - '0';
        ch = getchar();
    } while (ch >= '0' && ch <= '9');
    return f * x;
}
int main()
{
    //freopen("in.txt","r",stdin);
    int T = read();
    while (T--)
    {
        int n = read(), m = read();
        p = read();
        a[0] = 1;
        for (int i = 1; i <= p; i++)
            a[i] = (a[i - 1] * i) % p;
        cout << Lucas(n + m, n) << endl;
    }
}
```



