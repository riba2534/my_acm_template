# 使序列有序的最少交换次数

题意很简单，给出一个序列，你可以交换任意两个数字，问最少交换多少次可以使序列有序

这是一道经典的题，做法可以参考这个博客：[使序列有序的最少交换次数（minimum swaps）](https://www.cnblogs.com/kimsimple/p/6883572.html)

不过可能有些难理解，我用通俗的方法说一说，我们可以利用图论的方式来理解这个问题。

首先利用一个数组把序列里面的数的原来位置利用一个数组来记录一下，然后给原序列按照**升序**排序，我们知道了最终的结果，现在就是要如何从原来的位置，到达最终的位置的问题。

以样例来说明:

| 下标   | 1    | 2    | 3    | 4    | 5    |
| ------ | ---- | ---- | ---- | ---- | ---- |
| 排序前 | 1    | 3    | 2    | 5    | 4    |
| 排序后 | 1    | 2    | 3    | 4    | 5    |

那么我们看需要怎么换才能到达最终的位置，首先1这个元素不用换，因为它排序后还是在1这个位置，所以就给1自己连一条边，形成一个自环；元素3原来在2这个位置，但是排好序后它需要去3这个位置，而3这个位置的元素是2，那么这两个元素就需要交换，那么就给元素2和元素3之间连一条边，以此类推，连出所有的边如图：
![这里写图片描述](http://img.blog.csdn.net/20171218195929176?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcmliYTI1MzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)
1这个元素形成一个自环，2和3形成一个环，4和5形成一个环。我们知道，在一个环内，想把所有的元素都移动到最终的位置所需要的次数是**环内的元素个数-1**，那么我们有3个环，就需要连2次就够了。

那么我们得出一个结论，只需要求出环的个数，然后用总的元素数量减去环的数量就是最后的答案，也就是很多博客中的`循环节`
知道了原理，代码就很好写了，实现可以有很多种方式～

#代码

```cpp
#include <cstdio>
#include <cstring>
#include <cctype>
#include <stdlib.h>
#include <string>
#include <set>
#include <iostream>
#include <stack>
#include <cmath>
#include <queue>
#include <vector>
#include <algorithm>
using namespace std;
#define mem(a,b) memset(a,b,sizeof(a))
const int N=1000000+20;
int a[N],vis[N],m[N];
int main()
{
    int n,x;
    while(~scanf("%d",&n))
    {
        mem(a,0);
        mem(vis,0);
        for(int i=1; i<=n; i++)
        {
            scanf("%d",&a[i]);
            m[a[i]]=i;
        }
        sort(a+1,a+n+1);
        int ans=0;
        for(int i=1; i<=n; i++)
        {
            if(!vis[i])ans++;;
            int j=i;
            while(!vis[j])
            {
                vis[j]=1;
                j=m[a[j]];
            }
        }
        printf("%d\n",n-ans);
    }
    return 0;
}
```
有N台机器重量各不相等，现在要求把这些机器按照重量排序，重量从左到右依次递增。移动机器只能做交换操作，但交换机器要花费一定的费用，费用的大小就是交换机器重量的和。例如：3 
2 1，交换1 3后为递增排序，总的交换代价为4。给出N台机器的重量，求将所有机器变为有序的最小代价。（机器的重量均为正整数）

首先再做这一道题之前，最好请做一下最小交换次数，参考我的上一篇博客
[使序列有序的最少交换次数（minimum swaps）](https://www.cnblogs.com/kimsimple/p/6883572.html)

我继续转化成图论的方式来理解一下

我们以一组样例来说明：

	5
	1 8 9 7 6
首先对这个序列进行排序

| 下标   | 1    | 2    | 3    | 4    | 5    |
| ------ | ---- | ---- | ---- | ---- | ---- |
| 排序前 | 1    | 8    | 9    | 7    | 6    |
| 排序后 | 1    | 6    | 7    | 8    | 9    |

我们从元素1开始看，排序后元素1的位置还是1，那么就给1到1之间连一条边，形成一个自环；再到元素8，元素8排序以后到了第4个位置，而第四个位置是元素7，所以给8到7之间连一条有向边，同理连完剩下的边可以得到一张图：
![这里写图片描述](http://img.blog.csdn.net/20171218230027729?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvcmliYTI1MzQ=/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast)

那么我们可以发现两个环，那么我们回到题目中来，要使最后的总和最小，我们的贪心思路是什么？
一：
对于每一个环的贪心思路就是，找到这个环中最小的那个点，也就是6，然后从6开始进行交换，6和9交换，可以使9到对应的位置，花费为`6+9=15`,然后6和7交换，花费为`6+7=13`，最后等到交换完毕，自最后的答案是什么呢？就是：
$$
(6+9)+(6+7)+(6+8)=(6+7+8+9)+6*2=30+12=42
$$
剩下一个环不用交换，那么当前的最小值就是42，但是这还不是最优解

二:
我们考虑，在这个图中找到一个最小的值，然后用这个值跟着当前的环进行交换，在这个图中很明显是1，我们让第1和第二个环中的最小值6进行交换，然后再像上面一样，交换1和9，花费为:`1+9=10`，交换1和7，花费为：`1+7=8`等到交换完毕，最后的结果是:
$$
(1+6)+(1+9)+(1+7)+(1+8)+(1+6)=(6+8+7+9)+1*5+6=41
$$

所以41比42小，显然41更优，所以我们的贪心策略就是在这两者之间，找出一个最小值

参考:[51NOD1125交换机器的最小代价(贪心算法)](http://blog.csdn.net/say_c_box/article/details/50679673)

代码

```cpp
#include <cstdio>
#include <cstring>
#include <cctype>
#include <stdlib.h>
#include <string>
#include <map>
#include <iostream>
#include <stack>
#include <cmath>
#include <queue>
#include <vector>
#include <algorithm>
using namespace std;
typedef long long ll;
#define inf 0x3f3f3f3f
#define mem(a,b) memset(a,b,sizeof(a))
const ll N=50000+20;
ll a[N],vis[N];
ll least;
map<ll,ll>m;
ll solve(ll i)
{
    ll j=m[a[i]];
    ll minn=a[i];
    vis[i]=1;
    ll x=0,num=a[i];
    while(i!=j)
    {
        num+=a[j];
        minn=min(minn,a[j]);
        vis[j]=1;
        x++;
        j=m[a[j]];
    }
    printf("x=%d,num=%d\n",x,num);
    return num+min(minn*(x-1),least*(x+2)+minn);
}
int main()
{
    mem(vis,0);
    ll n,x;
    scanf("%lld",&n);
    for(ll i=1; i<=n; i++)
    {
        scanf("%lld",&a[i]);
        m[a[i]]=i;
    }
    sort(a+1,a+n+1);
    least=a[1];
    ll ans=0;
    for(ll i=1; i<=n; i++)
    {
        if(!vis[i])
        {
            ans+=solve(i);
        }
    }
    printf("%lld\n",ans);
    return 0;
}
```